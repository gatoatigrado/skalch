#LyX 1.6.4 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{ntung_personal}
\end_preamble
\use_default_options true
\language english
\inputencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Skalch 0.03 – Developing
\end_layout

\begin_layout Author
Nicholas Tung
\end_layout

\begin_layout Abstract
The software_documentation file covers how to check out the source code,
 and build Skalch.
 This document is dedicated to how the compiler is organized, and how to
 write graph transformations.
 The graph transformations software, GrGen, contains an excellent, detailed
 manual (in that repository's doc folder).
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{multicols}{2}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Compilation Stages
\end_layout

\begin_layout Standard
Several stages are executed during compilation.
 First, the Scala source is processed using the Scala compiler and Skalch's
 compiler plugin, which (among other things) dumps the source to the gxl
 graph format.
 This is then imported by GrGen, lowered (removing Scala AST explosion),
 and saved.
 Then, a Scala tool performs a discrete union of that graph with graphs
 for any library classes.
 Final GrGen stages are run.
 The graph is then imported by Java code, which initialize the SKETCH AST.
 The Java code in the last stage is generated by Python.
\end_layout

\begin_layout Paragraph
Compiler plugin
\end_layout

\begin_layout Itemize
Saves annotations, since they are discarded by further lowering stages.
\end_layout

\begin_layout Itemize
Exports the tree of any Scala source file to the GXL file format.
\end_layout

\begin_layout Paragraph
GrGen stages
\end_layout

\begin_layout Itemize
Delete classes marked as ignore, warn if any unsupported features are encountere
d.
\end_layout

\begin_layout Itemize
Convert $this variables to explicit function parameters.
\end_layout

\begin_layout Itemize
Annotate symbol types, and make SKETCH constructs (assert, ??, !!) special
 nodes.
\end_layout

\begin_layout Itemize
Convert function bodies to blocks, and add return statements to non-unit-type
 functions.
\end_layout

\begin_layout Itemize
List modernization
\end_layout

\begin_layout Itemize
Process annotations
\end_layout

\begin_layout Itemize
Array lowering
\end_layout

\begin_layout Itemize
Write list of required libraries, run external discrete union script, and
 restart.
\end_layout

\begin_layout Itemize
Convert Scala-style nodes (e.g.
 if statements, blocks as expressions) to C-style nodes
\end_layout

\begin_layout Itemize
This involves creation of a CFG, which determines how nodes can be moved.
\end_layout

\begin_layout Itemize
Final cleanup for SKETCH import (changing nodes to their base type, like
 ScalaSymbol --> Symbol)
\end_layout

\begin_layout Subsection
Commands
\end_layout

\begin_layout Standard
The compiler plugin is run with 
\series bold
make compile
\series default
.
 The Scala file usually used for developing, 
\series bold
SugaredTest.scala
\series default
, can be compiled with 
\series bold
make py-fsc-compile
\series default
.
 This is faster, but doesn't recompile the plugin.
 After you run this [to generate intermediate GXL for your program],
\end_layout

\begin_layout Standard
Typical GrGen development consists of running 
\series bold
make -j ycomp
\series default
 a lot--this runs GrGen's visualization library, 
\series bold
ycomp
\series default
.
 This displays the compiler graph before the final stages, since those stages
 remove useful information you want when transforming the tree.
 If you do want to view other stages, first 
\series bold
source ./env
\series default
, then run
\end_layout

\begin_layout Itemize

\series bold
make -j stagetf-compile; tf-test --debugafter initial_import 
\series default

\begin_inset Newline newline
\end_inset

To visualize the initial Scala AST, as exported by the plugin
\end_layout

\begin_layout Itemize

\series bold
make -j stagetf-compile; tf-test --debugafter SketchFinalMinorCleanup
\series default

\begin_inset Newline newline
\end_inset

To visualize the SKETCH AST, after all transformations.
\end_layout

\begin_layout Standard
The compiler graph sometimes looks huge, so it's good to work with small
 examples, write rules that simplify the AST so you can manipulate it at
 a higher level (though don't unnecessarily delete links), and get used
 to ycomp's search, and node highlighting (specified through the 
\series bold
.grs
\series default
 files, or grs sections in 
\series bold
.unified.grg
\series default
 files).
\end_layout

\begin_layout Standard
Then, navigate between nodes by right-clicking edges and selecting “
\series bold
source
\series default
” or “
\series bold
target
\series default
”.
 Right clicking nodes or edges and selecting “
\series bold
show attributes
\series default
” is also helpful—sometimes when you want a persistent box, other times
 the edges are drawn too close together to read their labels easily.
 It takes a bit of getting used to, but you will be able to navigate large
 graphs easily (though if you find a better tool than ycomp, let me know!).
\end_layout

\begin_layout Subsection
Stage details
\end_layout

\begin_layout Subsubsection
Adding function blocks and retyping Scala blocks
\end_layout

\begin_layout Standard
First, we want to ensure all functions have blocks as bodies, i.e.
 change the Scala syntax of “def f(x) = x” into “def f(x) = { x }”.
 The rewrite production looks like this:
\end_layout

\begin_layout Standard
insert scan here
\end_layout

\begin_layout Standard
Scala blocks have an expression value, so “{ x ; y }” will return the latest
 value of “y” at the end.
 SKETCH, by contrast, has C-style blocks.
 At the top level
\end_layout

\begin_layout Subsubsection
List modernization
\end_layout

\begin_layout Standard
TODO -- insert scan here
\end_layout

\begin_layout Standard
There are several macros and functions to help with list modernization.
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{{ macros.finiteList([names], lstname="lst") }}
\end_layout

\end_inset

generates a subgraph to match an argument.
 Since it actually generates a few lines of matching code (therefore it
 needs to output semicolons), don't place a semicolon after it (
\series bold
grep
\series default
 grg files for examples).
\end_layout

\begin_layout Subsubsection
Annotation processing 
\end_layout

\begin_layout Standard
In this step, we rewrite the plugin's 
\begin_inset Quotes eld
\end_inset

{ tmp = X : AnnotatedType; tmp }
\begin_inset Quotes erd
\end_inset

 blocks, then we replace Scala's 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $m$
\end_inset

 to 
\begin_inset Formula $M$
\end_inset


\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $m$
\end_inset

 until 
\begin_inset Formula $S$
\end_inset


\begin_inset Quotes erd
\end_inset

 notation with much simplified trees.
 We then calculate which functions need
\end_layout

\begin_layout Section
Writing graph transformations
\end_layout

\begin_layout Standard
Please skim the GrGen manual first, to learn the basics of graph rewriting.
\end_layout

\begin_layout Subsection
Basics
\end_layout

\begin_layout Standard
To start a new module, run 
\series bold
make new-unified-module
\series default
.
 This will prompt you for a module name, and update 
\series bold
transform.template.grs
\series default
 (the top-level rewrite sequence), and 
\series bold
AllRules.grg
\series default
 (the top-level actions / rules file).
\end_layout

\begin_layout Subsection
Guidelines
\end_layout

\begin_layout Standard
To make the modules composable and easy to follow, please follow a few conventio
ns.
\end_layout

\begin_layout Itemize
Comment or document your work, as done here.
\end_layout

\begin_layout Itemize
Don't delete edges (generally, information) you don't 
\emph on
think
\emph default
 you'll need.
 Later stages might rely on them.
\end_layout

\begin_layout Itemize
Make sure any new nodes extend base classes when appropriate, most likely
 
\series bold
Symbol
\series default
, or 
\series bold
ScAstNode
\series default
.
\begin_inset Newline newline
\end_inset

The same goes for edges, where the most common classes are 
\series bold
Subtree
\series default
, 
\series bold
Sibling
\series default
, 
\series bold
ScTermSymbol
\series default
, and 
\series bold
ScTypeSymbol
\series default
.
\end_layout

\begin_layout Itemize
Write test functions.
\end_layout

\begin_layout Paragraph
Test functions
\end_layout

\begin_layout Standard
Often, after a rewriting stage, you may want to check that a certain pattern
 is 
\emph on
not
\emph default
 present.
 The best way to do this is to write the pattern
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

test existsBadNode { x:BadNodeType; }
\end_layout

\end_inset

Then, after rewriting, add the following
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

validate exitonfailure xgrs ! existsBadNode
\end_layout

\end_inset

If the check is failing, you can debug it by simply running the search
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

debug xgrs existsBadNode
\end_layout

\end_inset

You can then run through the transformation steps in 
\series bold
ycomp
\series default
 (GrGen's visualization system) by pressing 
\series bold
d
\series default
 (detailed step), as explained in the GrGen manual.
\end_layout

\begin_layout Subsection
Troubleshooting
\end_layout

\begin_layout Standard
If your rewrite hangs, try running with the 
\begin_inset Quotes eld
\end_inset

--verbose
\begin_inset Quotes erd
\end_inset

 flag, to see which rule ran last.
 Most likely, some 
\begin_inset Quotes eld
\end_inset

rule*
\begin_inset Quotes erd
\end_inset

 is rewriting the graph in a way such that it is applied indefinitely, e.g.
 adding an edge without deleting any.
 If a rewrite hangs, or doesn't apply when you think it should, try running
 --debugrule, and press 
\begin_inset Quotes eld
\end_inset

d
\begin_inset Quotes erd
\end_inset

 
\emph on
in the console window, not ycomp
\emph default
 to see if GrGen finds a potential match.
\end_layout

\begin_layout Subsection
Examples
\end_layout

\begin_layout Subsubsection
Setting 
\begin_inset Quotes eld
\end_inset

enclosing function
\begin_inset Quotes erd
\end_inset

 links
\end_layout

\begin_layout Standard
In order to build a call graph, we want links from any node to its enclosing
 function.
 This rule uses GrGen's new recursive subpattern matching to match all subnodes
 in one shot (no recursive 
\series bold
exec
\series default
 or 
\series bold
negative
\series default
 statements required).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// === set enclosing function ===
\end_layout

\begin_layout Plain Layout

rule setEnclosingFunctionInitial {
\end_layout

\begin_layout Plain Layout

    x:FcnDef;
\end_layout

\begin_layout Plain Layout

    ise:iteratedSetEnclosing(x, x);
\end_layout

\begin_layout Plain Layout

    modify { ise(); }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pattern iteratedSetEnclosing(x:ScAstNode, fcn:FcnDef) {
\end_layout

\begin_layout Plain Layout

    hom(x, fcn);
\end_layout

\begin_layout Plain Layout

    iterated {
\end_layout

\begin_layout Plain Layout

        x -:Subtree-> y:ScAstNode;
\end_layout

\begin_layout Plain Layout

        ise:iteratedSetEnclosing(y, fcn);
\end_layout

\begin_layout Plain Layout

        modify { ise(); }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    iterated {
\end_layout

\begin_layout Plain Layout

        x -:Subtree-> lst:List;
\end_layout

\begin_layout Plain Layout

        iterated {
\end_layout

\begin_layout Plain Layout

            lst -:ListElt-> :ListNode -:ListValue-> y:ScAstNode;
\end_layout

\begin_layout Plain Layout

            ise:iteratedSetEnclosing(y, fcn);
\end_layout

\begin_layout Plain Layout

            modify { ise(); }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        modify { }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    modify { x -:EnclosingFcn-> fcn; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Creating an IsSubtree relation with GrGen's recursive patterns
\end_layout

\begin_layout Standard
We can use GrGen's recursive patterns to express the relation that a node
 is a subtree of another.
 We have edges 
\series bold
Subtree
\series default
, and the more complicated list structure.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

pattern IsSubtree(x:Node, y:Node) {
\end_layout

\begin_layout Plain Layout

    alternative {
\end_layout

\begin_layout Plain Layout

        DirectChild { x -:Subtree-> y; }
\end_layout

\begin_layout Plain Layout

        ListChild { x -:ListElt-> :ListNode -:ListValue-> y; }
\end_layout

\begin_layout Plain Layout

        RecursiveChild { x -:Subtree-> z:Node; :IsSubtree(z, y); }
\end_layout

\begin_layout Plain Layout

        RecursiveListChild { x -:ListElt-> :ListNode -:ListValue-> z:Node;
 :IsSubtree(z, y); }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can use this pattern to replace all CFG nodes belonging to a function's
 parameter list (unnecessarily created by previous rules, since the ValDefs
 are regular AST nodes).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rule cfgDeleteParamsNodes {
\end_layout

\begin_layout Plain Layout

    :FcnDef -:FcnDefParamsList-> lst:List;
\end_layout

\begin_layout Plain Layout

    y:ScAstNode --> z:CfgAbstractNode;
\end_layout

\begin_layout Plain Layout

    :IsSubtree(lst, y);
\end_layout

\begin_layout Plain Layout

    modify { delete(z); }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{multicols}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
