// author: gatoatigrado (nicholas tung) [ntung at ntung]

using ScalaAstModel;



// decorate nodes with relevant information

rule addScalaRoot {
    pkg:PackageDef;
    modify { pkg --> :SKRoot; }
}

rule setEnclosingFunctionInitial {
    x:FcnDef --> y:ScAstNode;
    negative {
        y -:EnclosingFcn->;
    }
    modify {
        y -:EnclosingFcn-> x;
    }
}

rule setEnclosingFunction {
    x:ScAstNode -:EnclosingFcn -> fcn:FcnDef;
    x --> y:ScAstNode;
    negative {
        y -:EnclosingFcn ->;
    }
    modify {
        y -:EnclosingFcn -> fcn;
    }
}

rule replaceAngelicSketchSymbol {
    cls_sym:Symbol -:SymbolOwner-> pkg_sym:Symbol;
    if {
        cls_sym.symbolName == "AngelicSketch";
        pkg_sym.symbolName == "skalch";
        typeof(cls_sym) == Symbol;
    }
    modify {
        angelicsym:AngelicSketchSymbol<cls_sym>;
    }
}

rule replaceAssertSymbol {
    fcnsym:Symbol -:SymbolOwner-> :AngelicSketchSymbol;
    if {
        fcnsym.symbolName == "synthAssert";
        typeof(fcnsym) == Symbol;
    }
    modify {
        assertsym:AssertFcnSymbol<fcnsym>;
    }
}

rule replaceBangBangSymbol {
    fcnsym:Symbol -:SymbolOwner-> :AngelicSketchSymbol;
    if {
        fcnsym.symbolName == "$bang$bang";
        typeof(fcnsym) == Symbol;
    }
    modify {
        assertsym:BangBangSymbol<fcnsym>;
    }
}

rule replaceHoleSymbol {
    fcnsym:Symbol -:SymbolOwner-> :AngelicSketchSymbol;
    if {
        fcnsym.symbolName == "$qmark$qmark";
        typeof(fcnsym) == Symbol;
    }
    modify {
        assertsym:HoleSymbol<fcnsym>;
    }
}

rule setScalaRoot {
    s1:Symbol;
    if { s1.fullSymbolName == "scala"; }
    modify { rt:ScalaSymbol<s1>; }
}

rule setScalaSubtypes {
    s1:Symbol -:SymbolOwner-> s2:ScalaSymbol;
    if { typeof(s1) == Symbol; }
    modify { rt1:ScalaSymbol<s1>; }
}

// rule setStaticAnnotationTypes {
//     s1:Symbol
// }

test testFail { negative { } }



// overly verbose method to delete all bridge-function related nodes

rule deleteBridgeFunctions1 {
    x:ScAstNode -:EnclosingFcn-> :FcnDef -:FcnDefSymbol-> sym:Symbol;
    sym -:BridgeFcn-> sym;
    modify {
        delete(x);
    }
}

rule deleteBridgeFunctions2 {
    x:FcnDef -:FcnDefSymbol-> sym:Symbol;
    sym -:BridgeFcn-> sym;
    modify {
        delete(x);
    }
}

rule deleteBridgeFunctions3 {
    sym:Symbol -:BridgeFcn-> sym;
    modify { delete(sym); }
}

rule deleteBridgeFunctions {
    modify { exec(deleteBridgeFunctions1* &
        deleteBridgeFunctions2* &
        deleteBridgeFunctions3*); }
}

test testNoBridgeFunctions {
    negative {
        sym:Symbol -:BridgeFcn-> sym;
    }
}



// $then variable translation to function parameters

rule transformThisRef(fcn:FcnDef) {
    ths:This -:EnclosingFcn-> fcn;
    ths -thssymlink:ThisSymbol-> clssym:Symbol;
    fcn -:FcnDefParamsChain-> :ValDef -:ValDefSymbol-> thssym:Symbol;
    modify {
        thsref:VarRef<ths> -:VarRefSymbol-> thssym;
        delete(thssymlink);
    }
}

rule addThisParam(fcn:FcnDef) {
    fcn -:FcnDefParamsChain-> first:Node;
    replace {
        thsparam:ValDef;
        thssym:Symbol;
        fcn2:MemberFcn<fcn>;
        eval {
            thsparam.scalaSource = "artificially inserted $this variable";
            thssym.symbolName = "$this";
        }
        fcn2 -:FcnDefParamsChain-> thsparam;
        thsparam -:FcnDefParamsNext-> first;
        thsparam -:ValDefSymbol -> thssym;
    }
}

rule transformThis(fcn:FcnDef) {
    fcn -:FcnDefSymbol-> fcnsym:Symbol -:SymbolOwner-> cls:Symbol;
    fcnsym -:ClsMethod-> fcnsym;
    :ClassDef -:ClassDefSymbol-> cls;
    modify {
        exec(addThisParam(fcn) & transformThisRef(fcn)*);
    }
}

// wrapper for "[rule]" (apply to all matches) graph rewriting
rule transformFcnWrapper {
    fcn:FcnDef;
    modify { exec(transformThis(fcn)); }
}

test testNoThisNodes {
    negative {
        ths:This;
    }
    negative {
        . -:ThisSymbol-> .;
    }
}



// rewrite sketch constructs
rule replaceAssertCalls() {
    fcn:FcnCall -:FcnCallSymbol-> :AssertFcnSymbol;
    fcn -:FcnTarget-> . --> :AngelicSketchSymbol;
    modify {
        assert:SKAssert<fcn>;
    }
}

rule replaceBangBangCalls() {
    resolv_call:FcnCall -:FcnArgChain-> bang_bang_call:FcnCall
        -:FcnCallSymbol-> :BangBangSymbol;
    resolv_call -rcsymedge:FcnCallSymbol-> resolv_sym:Symbol;
    resolv_call -targetedge:FcnTarget-> .;
    if { resolv_sym.symbolName == "resolve"; }
    modify {
//         delete(bang_bang_call, rcsymedge, targetedge);
        new_call:BangBangCall<resolv_call>;
    }
}

// more artifacts from the Scala view
rule unboxConstructCalls() {
    unbox_call:FcnCall -:FcnCallSymbol-> unbox_sym:ScalaSymbol;
    unbox_call -:FcnArgChain-> constr_sym:SketchConstructCall;
    unbox_call -:FcnTarget-> n:Node;
    if { unbox_sym.fullSymbolName == "scala.Boolean.unbox"; }
    replace {
        n;
        boolean_call:typeof(constr_sym)<unbox_call>;
        boolean_call -:BooleanConstructCall-> boolean_call;
    }
}



// cleanup

rule deleteDangling {
    x:Node;
    // due to non-homomorphic matching, should delete nodes with self-edges
    negative {
        x;
        . --> x;
    }
    negative {
        if { typeof(x) == PackageDef; }
    }
    modify {
//         emit("deleting node ", x, "\n");
        delete(x);
    }
}

rule removeEnclosingLinks {
    . -e:EnclosingFcn-> .;
    modify {
        delete(e);
    }
}

rule allChecks {
    modify {
        exec(! testNoBridgeFunctions);
    }
}
