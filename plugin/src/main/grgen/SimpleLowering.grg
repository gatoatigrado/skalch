// author: gatoatigrado (nicholas tung) [ntung at ntung]

using ScalaAstModel;



// decorate nodes with relevant information

rule setEnclosingFunctionInitial {
    x:FcnDef --> y:ScAstNode;
    negative {
        y -:EnclosingFcn->;
    }
    modify {
        y -:EnclosingFcn-> x;
    }
}

rule setEnclosingFunction {
    x:ScAstNode -:EnclosingFcn -> fcn:FcnDef;
    x --> y:ScAstNode;
    negative {
        y -:EnclosingFcn ->;
    }
    modify {
        y -:EnclosingFcn -> fcn;
    }
}

rule replaceAngelicSketch {
    cls_sym:Symbol -:SymbolOwner-> pkg_sym:Symbol;
    if {
        cls_sym.symbolName == "AngelicSketch";
        pkg_sym.symbolName == "skalch";
        typeof(cls_sym) == Symbol;
    }
    modify {
        angelicsym:AngelicSketchSymbol<cls_sym>;
    }
}

rule replaceAssertSymbol {
    fcnsym:Symbol -:SymbolOwner-> :AngelicSketchSymbol;
    if {
        fcnsym.symbolName == "synthAssert";
        typeof(fcnsym) == Symbol;
    }
    modify {
        assertsym:AssertFcnSymbol<fcnsym>;
    }
}

test testFail { negative { } }



// overly verbose method to delete all bridge-function related nodes

rule deleteBridgeFunctions1 {
    x:ScAstNode -:EnclosingFcn-> :FcnDef -:FcnDefSymbol-> sym:Symbol;
    sym -:BridgeFcn-> sym;
    modify {
        delete(x);
    }
}

rule deleteBridgeFunctions2 {
    x:FcnDef -:FcnDefSymbol-> sym:Symbol;
    sym -:BridgeFcn-> sym;
    modify {
        delete(x);
    }
}

rule deleteBridgeFunctions3 {
    sym:Symbol -:BridgeFcn-> sym;
    modify { delete(sym); }
}

rule deleteBridgeFunctions {
    modify { exec(deleteBridgeFunctions1* &
        deleteBridgeFunctions2* &
        deleteBridgeFunctions3*); }
}

test testNoBridgeFunctions {
    negative {
        sym:Symbol -:BridgeFcn-> sym;
    }
}



// $then variable translation to function parameters

rule transformThisRef(fcn:FcnDef) {
    ths:This -:EnclosingFcn-> fcn;
    ths -thssymlink:ThisSymbol-> clssym:Symbol;
    fcn -:FcnDefParamsChain-> :ValDef -:ValDefSymbol-> thssym:Symbol;
    modify {
        thsref:VarRef<ths> -:VarRefSymbol-> thssym;
        delete(thssymlink);
    }
}

rule addThisParam(fcn:FcnDef) {
    fcn -:FcnDefParamsChain-> first:Node;
    replace {
        thsparam:ValDef;
        thssym:Symbol;
        fcn2:MemberFcn<fcn>;
        eval {
            thsparam.scalaSource = "artificially inserted $this variable";
            thssym.symbolName = "$this";
        }
        fcn2 -:FcnDefParamsChain-> thsparam;
        thsparam -:FcnDefParamsNext-> first;
        thsparam -:ValDefSymbol -> thssym;
    }
}

rule transformThis(fcn:FcnDef) {
    fcn -:FcnDefSymbol-> fcnsym:Symbol -:SymbolOwner-> cls:Symbol;
    fcnsym -:ClsMethod-> fcnsym;
    :ClassDef -:ClassDefSymbol-> cls;
    modify {
        exec(addThisParam(fcn) & transformThisRef(fcn)*);
    }
}

// wrapper for "[rule]" (apply to all matches) graph rewriting
rule transformFcnWrapper {
    fcn:FcnDef;
    modify { exec(transformThis(fcn)); }
}

test testNoThisNodes {
    negative {
        ths:This;
    }
    negative {
        . -:ThisSymbol-> .;
    }
}



// rewrite sketch constructs
rule replaceAssertCalls() {
    fcn:FcnCall -:FcnCallSymbol-> :AssertFcnSymbol;
    fcn -:FcnTarget-> . --> :AngelicSketchSymbol;
    modify {
        assert:SKAssert<fcn>;
    }
}



// cleanup

rule deleteDangling {
    x:Node;
    negative {
        x;
        . --> x;
    }
    negative {
        if { typeof(x) == PackageDef; }
    }
    modify {
//         emit("deleting node ", x, "\n");
        delete(x);
    }
}

rule removeEnclosingLinks {
    . -e:EnclosingFcn-> .;
    modify {
        delete(e);
    }
}

rule allChecks {
    modify {
        exec(! testNoBridgeFunctions);
    }
}
