// -*- coding: utf-8 -*-
// author: gatoatigrado (nicholas tung) [ntung at ntung]

// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain a
// copy of the License at http://www.apache.org/licenses/LICENSE-2.0 .

// === README ===
// The current rewrites
//      (a) Create assignments to temporary variables
//      (b) The blocks know how to

rule retypeUnitTypeBlocks {
    block:Block -e_sym:BlockTypeSymbol-> unitsym:ScalaUnitTypeSymbol;
    block -e1:BlockStmtLast-> last:ScAstNode;
    block -e2:BlockExpr-> expr:ScAstNode;
    replace {
        next_block:SKBlock<block> -e_sym-> unitsym;
        last -e3:BlockStmtNext-> expr;
        block -e4:BlockStmtLast-> expr;
    }
}

rule convertFunctionBlocksToReturns {
    fcndef:FcnDef -:FcnBody-> block:Block
        -e:BlockExpr-> expr:ScAstNode;
    block -le:BlockStmtLast-> last:ScAstNode;
    block -:BlockTypeSymbol-> blk_typ:Symbol;
    modify {
        delete(e, le);
        ret:Return -:ReturnSymbol-> :InsertedReturnSymbol -:TypeSymbol-> blk_typ;
        last -:BlockStmtNext-> ret -:ReturnExpr-> expr;
        block -:BlockStmtLast-> ret;
        next_block:SKBlock<block>;
    }
}

// rule createImplicitBlocks {
//     fcndef:FcnDef -e:FcnBody-> expr:ScAstNode;
//     expr -:Blockify-> .;
//     expr --> s1:Symbol -:TypeSymbol-> s2:Symbol;
//     hom(s1, s2);
//     modify {
//         delete(e);
//         fcndef -:FcnBody-> blk:SKBlock -:BlockStmtChain-> ret:Return -:ReturnExpr-> expr;
//         blk -:BlockStmtLast-> ret;
//         ret -:ReturnSymbol-> :InsertedReturnSymbol -:TypeSymbol-> s2;
//         ret -:BlockifyNext-> expr;
//     }
// }

rule postsetValDefRhs(x : ValDef, y : ScAstNode) {
    modify { x -:ValDefRhs-> y; }
}

// move one sibling edges outgoing from x to be outgoing from y
rule redirect_outgoing_sibling_edges(x : ScAstNode, y : ScAstNode) {
    x -e:Sibling-> z:ScAstNode;
    modify {
        y -e2:typeof(e)-> z;
        delete(e);
    }
}

rule redirect_outgoing_cfg_edges(x : ScAstNode, y : ScAstNode) {
    x -e:AstCfgEdge-> z:CfgNode;
    modify {
        y -e2:typeof(e)-> z;
        delete(e);
    }
}

rule createTemporary(expr : ScAstNode, cfgnode : CfgNode) {
    modify {
        tmp_assign:BlockifyValDef -:ValDefSymbol-> tmpsym:TmpSymbol;
        ref:TmpVarRef -:VarRefSymbol-> tmpsym;
        cfgnode -:BlockifyExpr-> tmp_assign;
        // otherwise, order is not explicit
        exec(redirect_incoming(expr, ref)* &
            redirect_outgoing_sibling_edges(expr, ref)* &
            redirect_outgoing_cfg_edges(expr, ref)* &
            postsetValDefRhs(tmp_assign, expr));
    }
}

rule exprTargetsToNodes {
    . -:ExprTarget-> expr:ScalaExprStmt
        -:AstCfgEdge-> eval_node:CfgEvalNormalNode;
    modify {
        exec(createTemporary(expr, eval_node));
    }
}

/// need to blockify previous arguments so we don't change
/// the effective CFG order
rule propagateBlockifyMarkSafe {
    next_blockify:CfgNode -:CfgSequentialNext-> existing_blockify:CfgNode;
        expr:BlockifySafe -:AstCfgEdge-> next_blockify;
    existing_blockify -:AbstractBlockify-> .;
    negative { next_blockify -:AbstractBlockify-> .; }
    negative { existing_blockify -:CfgAbstractAttachable-> existing_blockify; }
    negative { next_blockify -:CfgAbstractAttachable-> next_blockify; }
    modify {
        next_blockify -:BlockifySkip-> :BlockifySkipNode;
    }
}

rule propagateBlockify {
    next_blockify:CfgNode -:CfgSequentialNext-> existing_blockify:CfgNode;
        expr:ScAstNode -:AstCfgEdge-> next_blockify;
    existing_blockify -:AbstractBlockify-> .;
    negative { next_blockify -:AbstractBlockify-> .; }
    negative { existing_blockify -:CfgAbstractAttachable-> existing_blockify; }
    negative { next_blockify -:CfgAbstractAttachable-> next_blockify; }
    modify {
        exec(createTemporary(expr, next_blockify));
    }
}

test testNoBlockifiedSafeNodes {
    negative {
        valdef:BlockifyValDef -:ValDefRhs-> safe:BlockifySafe
            -:AstCfgEdge-> cfgnode:CfgNode -:BlockifyExpr-> valdef;
    }
}

// NOTE -- this should definitely happen outside of creating temporaries, so
// all temporaries can be created before blockify links are set.
// NOTE -- this is not recursive because the blockify source node will
// be transformed into the target of a ValDefRhs instead of a FcnArg.

// rule propagateBlockify {
//     x:ScAstNode -:BlockifySubtreeInner-> y:ScAstNode;
//     z:ScAstNode -:FcnArg-> x;
//     modify {
//         exec(createTemporary(z, x));
//     }
// }

// rule cfgInitNormalNodes {
// }

// STEP 2: Links from CFG to CFG
// based on AST edge type

// rule fcnCallPrologue {
//     call -:FcnArgChain-> first;
//     call -:FcnArgLast-> last;
//     modify {
//     }
// }








// rule propagateBlockify2 {
//     z:ScAstNode --> x:ScAstNode -:FcnArg-> y:ScAstNode
//         -:BlockifyNext-> .;
// }

/*
rule createImplicitBlocks {
    fcndef:FcnDef -e:FcnBody-> expr:ScAstNode;
    expr -:Blockify-> .;
    expr --> s1:Symbol -:TypeSymbol-> s2:Symbol;
    hom(s1, s2);
    modify {
        delete(e);
        fcndef -:FcnBody-> blk:SKBlock -:BlockStmtChain-> ret:Return -:ReturnExpr-> expr;
        blk -:BlockStmtLast-> ret;
        ret -:ReturnSymbol-> :InsertedReturnSymbol -:TypeSymbol-> s2;
        ret -:BlockifyNext-> expr;
    }
}
*/

// rule insertBlockStmt(prev:ScAstNode, insert_before:ScAstNode, to_insert:ScAstNode) {
// }

// eat up the BlockifyNext links...
// rule insertNextBlockStmt(prev:ScAstNode, insert_before:ScAstNode, to_insert:ScAstNode) {
// }

// rule followBlockifyNextFor(prev:ScAstNode, insert_before:ScAstNode, curr:ScAstNode) {
//     curr -e:BlockifyNext-> next:ScAstNode;
//     modify {
//         delete(e);
//         exec(followBlockifyLinkFor(prev, insert_before, curr));
//     }
// }
//
// // NOTE -- curr is only used as a ptr.
// rule followBlockifyFor(prev:ScAstNode, insert_before:ScAstNode, curr:ScAstNode) {
//     curr -e:Blockify-> next:ScAstNode;
//     modify {
//         delete(e);
//     }
// }
//
// rule followBlockifyLinkFor(prev:ScAstNode, insert_before:ScAstNode, curr:ScAstNode) {
//     modify {
//         exec(followBlockifyFor(prev, insert_before, curr) &
//             followBlockifyNextFor(prev, insert_before, curr));
//     }
// }

// === match api functions ===
// rule followBlockifyNext {
//     // if prev in in a block, this should already start at the beginning of the block.
//     prev:ScAstNode -e:BlockStmt-> blk_stmt:ScAstNode
//         -blockify_link:BlockifyNext-> next:ScAstNode;
//     modify { exec(followBlockifyLinkFor(prev, blk_stmt, blk_stmt)); }
// }







// rule blockify(before_insert:ScAstNode, after_insert:ScAstNode, x:ScAstNode) {
//     before_insert -e:BlockStmt-> after_insert;
//     x -e2:Blockify-> y:ScAstNode;
//     modify {
//         before_insert -:typeof(e)-> y -:BlockStmtNext-> after_insert;
//         delete(e, e2);
//     }
// }
//
// rule followBlockifyLinkChain(x:ScAstNode) : (ScAstNode) {
//     x -:BlockifyNext-> y:ScAstNode;
//     modify { return (y); }
// }
//
// rule findBlockifyLinks {
//     before_insert:ScAstNode -:BlockStmt-> after_insert:ScAstNode
//         -:BlockifyLink-> next:ScAstNode;
//     modify {
//         exec( (z:ScAstNode = after_insert) &
//             ((z) = followBlockifyLinkChain(z))* &&
//             blockify(before_insert, after_insert, z) );
//     }
// }







// rule insertBlockStmts {
//     prev -e:BlockStmt-> blk_stmt:ScAstNode -blockify_link:Blockify-> toinsert;
//     // debugging...
//     negative { blk_stmt -:BlockStmt-> to_insert; }
//     modify {
//         delete(blockify_link);
//         prev -:typeof(e)-> toinsert -:BlockStmtNext-> blk_stmt;
//     }
// }
