// -*- coding: utf-8 -*-
// author: gatoatigrado (nicholas tung) [ntung at ntung]

// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain a
// copy of the License at http://www.apache.org/licenses/LICENSE-2.0 .

// === README ===
// The current rewrites
//      (a) Create assignments to temporary variables
//      (b) The blocks know how to

rule retypeUnitTypeBlocks {
    block:Block -e_sym:BlockTypeSymbol-> unitsym:ScalaUnitTypeSymbol;
    block -e1:BlockStmtLast-> last:ScAstNode;
    block -e2:BlockExpr-> expr:ScAstNode;
    replace {
        next_block:SKBlock<block> -e_sym-> unitsym;
        last -e3:BlockStmtNext-> expr;
        block -e4:BlockStmtLast-> expr;
    }
}

rule convertFunctionBlocksToReturns {
    fcndef:FcnDef -:FcnBody-> block:Block
        -e:BlockExpr-> expr:ScAstNode;
    block -le:BlockStmtLast-> last:ScAstNode;
    block -:BlockTypeSymbol-> blk_typ:Symbol;
    modify {
        delete(e, le);
        ret:Return -:ReturnSymbol-> :InsertedReturnSymbol -:TypeSymbol-> blk_typ;
        last -:BlockStmtNext-> ret -:ReturnExpr-> expr;
        block -:BlockStmtLast-> ret;
        next_block:SKBlock<block>;
    }
}

// rule createImplicitBlocks {
//     fcndef:FcnDef -e:FcnBody-> expr:ScAstNode;
//     expr -:Blockify-> .;
//     expr --> s1:Symbol -:TypeSymbol-> s2:Symbol;
//     hom(s1, s2);
//     modify {
//         delete(e);
//         fcndef -:FcnBody-> blk:SKBlock -:BlockStmtChain-> ret:Return -:ReturnExpr-> expr;
//         blk -:BlockStmtLast-> ret;
//         ret -:ReturnSymbol-> :InsertedReturnSymbol -:TypeSymbol-> s2;
//         ret -:BlockifyNext-> expr;
//     }
// }

rule postsetValDefRhs(x : ValDef, y : ScAstNode) {
    modify { x -:ValDefRhs-> y; }
}

// redirect the chain from a previous argument to the new reference
rule redirect_outgoing_fcn_edges(prev_arg : ScAstNode, varref : ScAstNode) {
    prev_arg -e:FcnArg-> x:ScAstNode;
    modify {
        varref -e2:typeof(e)-> x;
        delete(e);
    }
}

rule createTemporary(from : ScAstNode, expr : ScAstNode) {
    modify {
        tmp_assign:BlockifyValDef -:ValDefSymbol-> tmpsym:TmpSymbol;
        ref:TmpVarRef -:VarRefSymbol-> tmpsym;
        ref -:BlockifySubtreeInner-> tmp_assign;
        // otherwise, order is not explicit
        exec(redirect_incoming(expr, ref)* &
            redirect_outgoing_fcn_edges(expr, ref)* &
            postsetValDefRhs(tmp_assign, expr));
    }
}

// NOTE -- if this is too special-case, then perhaps
// an edge class could be created to designate
// nodes which should be transformed to statements.
rule fcnArgsToStmts {
    from:ScAstNode -:FcnArg-> expr:ScalaExprStmt;
    modify {
        exec(createTemporary(from, expr));
    }
}

// NOTE -- this should definitely happen outside of creating temporaries, so
// all temporaries can be created before blockify links are set.
// NOTE -- this is not recursive because the blockify source node will
// be transformed into the target of a ValDefRhs instead of a FcnArg.

rule propagateBlockify {
    x:ScAstNode -:BlockifySubtreeInner-> y:ScAstNode;
    z:ScAstNode -:FcnArg-> x;
    modify {
        exec(createTemporary(z, x));
    }
}






// The control flow graph -- a structure linked to the AST.
// Currently, the CFG is used to attach additional data, which
// is moved back to the AST.

// STEP 1: Links from AST to CFG
// based on AST node type

rule cfgInitReturnNodes {
    ret:Return;
    negative { ret -:CfgPrologue-> .; }
    modify {
        ret -:CfgPrologue-> prologue:CfgEvalNormalNode;
        ret -:CfgEpilogue-> epilogue:CfgReturnNode;
    }
}

/// NOTE -- this function is slightly fragile, in that
/// return *must* be processed before.
rule cfgInitEnclosingNodes {
    x : ScAstNode -:Subtree-> :ScAstNode;

    // don't break function boundaries, and leave the graph
    // a little prettier. sync with below
    negative { if { typeof(x) <= ClassDef ||
        typeof(x) <= PackageDef || typeof(x) <= Template; } }

    negative { x -:CfgPrologue-> .; }
    modify {
        x -:CfgPrologue-> prologue:CfgDummyPrologueNode;
        x -:CfgEpilogue-> epilogue:CfgEvalNormalNode;
    }
}

/// this works if the others are initialized first :)
/// This code can also be used:
/// negative { if { typeof(x) < FcnCall; } }
/// negative { if { typeof(x) < Return; } }
rule cfgInitOtherNodes {
    x:ScAstNode;

    // sync with above
    negative { if { typeof(x) <= ClassDef ||
        typeof(x) <= PackageDef || typeof(x) <= Template; } }

    negative { x -:CfgPrologue-> .; }
    negative { x; x -:Subtree-> y:ScAstNode; }
    modify {
        x -:CfgPrologueEpilogue-> :CfgEvalNormalNode;
    }
}



// STEP 2: Edges from CFG to CFG nodes
// based on AST edge types

/// general function to wire x's epilogue to y's prologue.
rule cfgEpilogueToPrologueNext(x : ScAstNode, y : ScAstNode) {
    x -:CfgEpilogue-> x_epilogue:CfgNormalNode;
    y -:CfgPrologue-> y_prologue:CfgNormalNode;
    negative { x_epilogue -:CfgAbstractNext-> y_prologue; }
    modify { x_epilogue -:CfgNext-> y_prologue; }
}

/// general function to connect internal nodes (first and last) to
/// the prologue and epilogue of an enclosing node.
rule cfgEnclosingPrologueEpilogue(enclosing : ScAstNode,
    first : ScAstNode, last : ScAstNode)
{
    enclosing -:CfgPrologue-> enclosing_prologue:CfgNormalNode;
    enclosing -:CfgEpilogue-> enclosing_epilogue:CfgNormalNode;
    first -prologue_edge:CfgPrologue-> first_prologue:CfgNormalNode;
    last -epilogue_edge:CfgEpilogue-> last_epilogue:CfgNormalNode;
    hom(first, last);
    hom(prologue_edge, epilogue_edge);
    hom(first_prologue, last_epilogue);
    negative { enclosing_prologue -:CfgAbstractNext-> first_prologue; }
    negative { last_epilogue -:CfgAbstractNext-> enclosing_epilogue; }
    modify {
        enclosing_prologue -:CfgNext-> first_prologue;
        last_epilogue -:CfgNext-> enclosing_epilogue;
    }
}



rule cfgSetNextForValDef {
    valdef:ValDef -:ValDefRhs-> rhs:ScAstNode;
    negative { valdef -:tmpCfgDone-> valdef; }
    modify {
        valdef -:tmpCfgDone-> valdef;
        exec(cfgEnclosingPrologueEpilogue(valdef, rhs, rhs));
    }
}

rule cfgSetNextForBlockArgs {
    x:ScAstNode -:BlockStmtNext-> y:ScAstNode;
    negative { x -:tmpCfgDone-> x; }
    modify {
        x -:tmpCfgDone-> x;
        exec(cfgEpilogueToPrologueNext(x, y));
    }
}

rule cfgSetNextForScalaBlocks {
    block:Block;
    block -:BlockStmtChain-> first:ScAstNode;
    block -:BlockStmtLast-> last:ScAstNode;
    block -:BlockExpr-> expr:ScAstNode;
    hom(first, last);
    negative { block -:tmpCfgDone-> block; }
    modify {
        block -:tmpCfgDone-> block;
        exec(cfgEpilogueToPrologueNext(last, expr) |
             cfgEnclosingPrologueEpilogue(block, first, expr));
    }
}

rule cfgSetNextForSketchBlocks {
    block:SKBlock;
    block -:BlockStmtChain-> first:ScAstNode;
    block -:BlockStmtLast-> last:ScAstNode;
    hom(first, last);
    negative { block -:tmpCfgDone-> block; }
    modify {
        block -:tmpCfgDone-> block;
        exec(cfgEnclosingPrologueEpilogue(block, first, last));
    }
}

rule cfgSetNextForFcnArgs {
    x:ScAstNode -:CfgEpilogue-> x_epilogue:CfgNormalNode;
    y:ScAstNode -:CfgPrologue-> y_prologue:CfgNormalNode;
    x -:FcnArgNext-> y;
    negative { x_epilogue -:CfgAbstractNext-> y_prologue; }
    modify { x_epilogue -:CfgNext-> y_prologue; }
}

rule cfgSetNextIntraFcn {
    fcn:FcnCall -:FcnArgChain-> first:ScAstNode;
    fcn -:FcnArgLast-> last:ScAstNode;
    fcn -:CfgPrologue-> fcn_prologue:CfgNode;
    fcn -:CfgEpilogue-> fcn_epilogue:CfgNode;

    first -firstcfgedge:CfgPrologue-> firstcfgnode:CfgNode;
    last -lastcfgedge:CfgEpilogue-> lastcfgnode:CfgNode;

    hom(first, last);
    hom(firstcfgedge, lastcfgedge);
    hom(firstcfgnode, lastcfgnode);
    hom(fcn_prologue, fcn_epilogue); // in case behavior above changes

    negative { fcn_prologue -:CfgAbstractNext-> firstcfgnode; }
    negative { lastcfgnode -:CfgAbstractNext-> fcn_epilogue; }

    modify {
        fcn_prologue -:CfgNext-> firstcfgnode;
        lastcfgnode -:CfgNext-> fcn_epilogue;
    }
}

rule cfgSetNextFcnDef {
    fcndef:MemberFcn -:FcnBody-> body:ScAstNode;
    negative { fcndef -:tmpCfgDone-> fcndef; }
    modify {
        fcndef -:tmpCfgDone-> fcndef;
        exec(cfgEnclosingPrologueEpilogue(fcndef, body, body));
    }
}

rule cfgSetNextIgnoreSubtree {
    x:ScAstNode -:CfgPrologue-> y:CfgNormalNode;
    x -:CfgEpilogue-> z:CfgNormalNode;
    negative { y -:CfgAbstractNext-> .; }
    modify {
        y -:CfgSkipSubtreeNext-> z;
    }
}

rule deleteTmpEdges {
    y:Node -x:tmpCfgDone-> y;
    modify { delete(x); }
}

rule cfgInit {
    modify { exec(cfgInitReturnNodes* |
        cfgInitEnclosingNodes* |
        cfgInitOtherNodes* |

        // generate with
        // grep -oE 'rule cfgSetNext([a-zA-Z0-9]+)' | sed 's/rule //g' | awk '{ print $0 "* | [deleteTmpEdges] |"; }'
        cfgSetNextForValDef* | [deleteTmpEdges] |
        cfgSetNextForBlockArgs* | [deleteTmpEdges] |
        cfgSetNextForScalaBlocks* | [deleteTmpEdges] |
        cfgSetNextForSketchBlocks* | [deleteTmpEdges] |
        cfgSetNextForFcnArgs* | [deleteTmpEdges] |
        cfgSetNextIntraFcn* | [deleteTmpEdges] |
        cfgSetNextFcnDef* | [deleteTmpEdges] |
        cfgSetNextIgnoreSubtree* | [deleteTmpEdges] |

        [deleteTmpEdges]); }
}

// TEST -- member functions are connected from beginning to end
rule testCfgConnectedInit {
    fcn:MemberFcn -:CfgEpilogue-> epilogue:CfgNormalNode;
    modify {
        epilogue -:CfgIsConnected-> epilogue;
    }
}

rule testCfgConnectedPropagate {
    x:CfgNode -:CfgAbstractNext-> connected:CfgNode;
    connected -:CfgIsConnected-> connected;
    negative { x -:CfgIsConnected-> x; }
    modify {
        x -:CfgIsConnected-> x;
    }
}

rule testCfgConnectedFcnDefsEchoError {
    fcn:MemberFcn -:CfgPrologue-> prologue:CfgNormalNode;
    fcn -:ScTermSymbol-> fcnsym:Symbol;
    negative {
        prologue -:CfgIsConnected-> prologue;
    }
    modify { emit("[GRG ASSERT FAILURE] unconnected function: "
        + fcnsym.symbolName + "\n"); }
}

rule testCfgConnectedEchoError {
    x:ScAstNode --> cfgnode:CfgNormalNode;
    negative {
        cfgnode -:CfgAbstractNext-> z:Node;
        a:Node -:CfgAbstractNext-> cfgnode;
        hom(a, z);
    }
    modify { emit("[GRG ASSERT FAILURE] unconnected node: ");
        emit(x); emit("\n"); }
}

// rule cfgInitNormalNodes {
// }

// STEP 2: Links from CFG to CFG
// based on AST edge type

// rule fcnCallPrologue {
//     call -:FcnArgChain-> first;
//     call -:FcnArgLast-> last;
//     modify {
//     }
// }








// rule propagateBlockify2 {
//     z:ScAstNode --> x:ScAstNode -:FcnArg-> y:ScAstNode
//         -:BlockifyNext-> .;
// }

/*
rule createImplicitBlocks {
    fcndef:FcnDef -e:FcnBody-> expr:ScAstNode;
    expr -:Blockify-> .;
    expr --> s1:Symbol -:TypeSymbol-> s2:Symbol;
    hom(s1, s2);
    modify {
        delete(e);
        fcndef -:FcnBody-> blk:SKBlock -:BlockStmtChain-> ret:Return -:ReturnExpr-> expr;
        blk -:BlockStmtLast-> ret;
        ret -:ReturnSymbol-> :InsertedReturnSymbol -:TypeSymbol-> s2;
        ret -:BlockifyNext-> expr;
    }
}
*/

// rule insertBlockStmt(prev:ScAstNode, insert_before:ScAstNode, to_insert:ScAstNode) {
// }

// eat up the BlockifyNext links...
// rule insertNextBlockStmt(prev:ScAstNode, insert_before:ScAstNode, to_insert:ScAstNode) {
// }

// rule followBlockifyNextFor(prev:ScAstNode, insert_before:ScAstNode, curr:ScAstNode) {
//     curr -e:BlockifyNext-> next:ScAstNode;
//     modify {
//         delete(e);
//         exec(followBlockifyLinkFor(prev, insert_before, curr));
//     }
// }
//
// // NOTE -- curr is only used as a ptr.
// rule followBlockifyFor(prev:ScAstNode, insert_before:ScAstNode, curr:ScAstNode) {
//     curr -e:Blockify-> next:ScAstNode;
//     modify {
//         delete(e);
//     }
// }
//
// rule followBlockifyLinkFor(prev:ScAstNode, insert_before:ScAstNode, curr:ScAstNode) {
//     modify {
//         exec(followBlockifyFor(prev, insert_before, curr) &
//             followBlockifyNextFor(prev, insert_before, curr));
//     }
// }

// === match api functions ===
// rule followBlockifyNext {
//     // if prev in in a block, this should already start at the beginning of the block.
//     prev:ScAstNode -e:BlockStmt-> blk_stmt:ScAstNode
//         -blockify_link:BlockifyNext-> next:ScAstNode;
//     modify { exec(followBlockifyLinkFor(prev, blk_stmt, blk_stmt)); }
// }







// rule blockify(before_insert:ScAstNode, after_insert:ScAstNode, x:ScAstNode) {
//     before_insert -e:BlockStmt-> after_insert;
//     x -e2:Blockify-> y:ScAstNode;
//     modify {
//         before_insert -:typeof(e)-> y -:BlockStmtNext-> after_insert;
//         delete(e, e2);
//     }
// }
//
// rule followBlockifyLinkChain(x:ScAstNode) : (ScAstNode) {
//     x -:BlockifyNext-> y:ScAstNode;
//     modify { return (y); }
// }
//
// rule findBlockifyLinks {
//     before_insert:ScAstNode -:BlockStmt-> after_insert:ScAstNode
//         -:BlockifyLink-> next:ScAstNode;
//     modify {
//         exec( (z:ScAstNode = after_insert) &
//             ((z) = followBlockifyLinkChain(z))* &&
//             blockify(before_insert, after_insert, z) );
//     }
// }







// rule insertBlockStmts {
//     prev -e:BlockStmt-> blk_stmt:ScAstNode -blockify_link:Blockify-> toinsert;
//     // debugging...
//     negative { blk_stmt -:BlockStmt-> to_insert; }
//     modify {
//         delete(blockify_link);
//         prev -:typeof(e)-> toinsert -:BlockStmtNext-> blk_stmt;
//     }
// }
