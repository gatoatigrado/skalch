// -*- coding: utf-8 -*-
// author: gatoatigrado (nicholas tung) [ntung at ntung]

// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain a
// copy of the License at http://www.apache.org/licenses/LICENSE-2.0 .

// The control flow graph -- a structure linked to the AST.
// Currently, the CFG is used to attach additional data, which
// is moved back to the AST.

// STEP 1: Links from AST to CFG
// based on AST node type

rule cfgInitReturnNodes {
    ret:Return;
    negative { ret -:CfgPrologue-> .; }
    modify {
        ret -:CfgPrologue-> prologue:CfgEvalNormalNode;
        ret -:CfgEpilogue-> epilogue:CfgReturnNode;
    }
}

/// NOTE -- this function is slightly fragile, in that
/// return *must* be processed before.
rule cfgInitEnclosingNodes {
    x : ScAstNode -:Subtree-> :ScAstNode;

    // don't break function boundaries, and leave the graph
    // a little prettier. sync with below
    negative { if { typeof(x) <= ClassDef ||
        typeof(x) <= PackageDef || typeof(x) <= Template; } }

    negative { x -:CfgPrologue-> .; }
    modify {
        x -:CfgPrologue-> prologue:CfgDummyPrologueNode;
        x -:CfgEpilogue-> epilogue:CfgEvalNormalNode;
    }
}

/// this works if the others are initialized first :)
/// This code can also be used:
/// negative { if { typeof(x) < FcnCall; } }
/// negative { if { typeof(x) < Return; } }
rule cfgInitOtherNodes {
    x:ScAstNode;

    // sync with above
    negative { if { typeof(x) <= ClassDef ||
        typeof(x) <= PackageDef || typeof(x) <= Template; } }

    negative { x -:CfgPrologue-> .; }
    negative { x; x -:Subtree-> y:ScAstNode; }
    modify {
        x -:CfgPrologueEpilogue-> :CfgEvalNormalNode;
    }
}



// STEP 2: Edges from CFG to CFG nodes
// based on AST edge types

/// general function to wire x's epilogue to y's prologue.
rule cfgEpilogueToPrologueNext(x : ScAstNode, y : ScAstNode) {
    x -:CfgEpilogue-> x_epilogue:CfgNormalNode;
    y -:CfgPrologue-> y_prologue:CfgNormalNode;
    negative { x_epilogue -:CfgAbstractNext-> y_prologue; }
    modify { x_epilogue -:CfgNext-> y_prologue; }
}

/// general function to connect internal nodes (first and last) to
/// the prologue and epilogue of an enclosing node.
rule cfgEnclosingPrologueEpilogue(enclosing : ScAstNode,
    first : ScAstNode, last : ScAstNode)
{
    enclosing -:CfgPrologue-> enclosing_prologue:CfgNormalNode;
    enclosing -:CfgEpilogue-> enclosing_epilogue:CfgNormalNode;
    first -prologue_edge:CfgPrologue-> first_prologue:CfgNormalNode;
    last -epilogue_edge:CfgEpilogue-> last_epilogue:CfgNormalNode;
    hom(first, last);
    hom(prologue_edge, epilogue_edge);
    hom(first_prologue, last_epilogue);
    negative { enclosing_prologue -:CfgAbstractNext-> first_prologue; }
    negative { last_epilogue -:CfgAbstractNext-> enclosing_epilogue; }
    modify {
        enclosing_prologue -:CfgNext-> first_prologue;
        last_epilogue -:CfgNext-> enclosing_epilogue;
    }
}

rule cfgSetAttachableMemberFcns {
    fcndef:MemberFcn -:CfgPrologue-> prologue:CfgNormalNode;
    negative { prologue -:CfgAbstractAttachable-> prologue; }
    modify { prologue -:CfgImplicitAttachable-> prologue; }
}

// won't conflict above since member functions won't be in blocks.
rule cfgSetAttachableBlocks {
    . -:BlockStmt-> x:ScAstNode -:CfgPrologue-> prologue:CfgNormalNode;
    negative { prologue -:CfgAbstractAttachable-> prologue; }
    modify { prologue -:CfgAttachable-> prologue; }
}

// won't conflict above since member functions won't be in blocks.
rule cfgSetAttachableBlockExpr {
    . -:BlockExpr-> x:ScAstNode -:CfgPrologue-> prologue:CfgNormalNode;
    negative { prologue -:CfgAbstractAttachable-> prologue; }
    modify { prologue -:CfgAttachable-> prologue; }
}



rule cfgSetNextForValDef {
    valdef:ValDef -:ValDefRhs-> rhs:ScAstNode;
    negative { valdef -:tmpCfgDone-> valdef; }
    modify {
        valdef -:tmpCfgDone-> valdef;
        exec(cfgEnclosingPrologueEpilogue(valdef, rhs, rhs));
    }
}

rule cfgSetNextForBlockArgs {
    x:ScAstNode -:BlockStmtNext-> y:ScAstNode;
    negative { x -:tmpCfgDone-> x; }
    modify {
        x -:tmpCfgDone-> x;
        exec(cfgEpilogueToPrologueNext(x, y));
    }
}

rule cfgSetNextForScalaBlocks {
    block:Block;
    block -:BlockStmtChain-> first:ScAstNode;
    block -:BlockStmtLast-> last:ScAstNode;
    block -:BlockExpr-> expr:ScAstNode;
    hom(first, last);
    negative { block -:tmpCfgDone-> block; }
    modify {
        block -:tmpCfgDone-> block;
        exec(cfgEpilogueToPrologueNext(last, expr) |
             cfgEnclosingPrologueEpilogue(block, first, expr));
    }
}

rule cfgSetNextForSketchBlocks {
    block:SKBlock;
    block -:BlockStmtChain-> first:ScAstNode;
    block -:BlockStmtLast-> last:ScAstNode;
    hom(first, last);
    negative { block -:tmpCfgDone-> block; }
    modify {
        block -:tmpCfgDone-> block;
        exec(cfgEnclosingPrologueEpilogue(block, first, last));
    }
}

rule cfgSetNextForFcnArgs {
    x:ScAstNode -:CfgEpilogue-> x_epilogue:CfgNormalNode;
    y:ScAstNode -:CfgPrologue-> y_prologue:CfgNormalNode;
    x -:FcnArgNext-> y;
    negative { x_epilogue -:CfgAbstractNext-> y_prologue; }
    modify { x_epilogue -:CfgNext-> y_prologue; }
}

rule cfgSetNextIntraFcn {
    fcn:FcnCall -:FcnArgChain-> first:ScAstNode;
    fcn -:FcnArgLast-> last:ScAstNode;
    fcn -:CfgPrologue-> fcn_prologue:CfgAbstractNode;
    fcn -:CfgEpilogue-> fcn_epilogue:CfgAbstractNode;

    first -firstcfgedge:CfgPrologue-> firstcfgnode:CfgAbstractNode;
    last -lastcfgedge:CfgEpilogue-> lastcfgnode:CfgAbstractNode;

    hom(first, last);
    hom(firstcfgedge, lastcfgedge);
    hom(firstcfgnode, lastcfgnode);
    hom(fcn_prologue, fcn_epilogue); // in case behavior above changes

    negative { fcn_prologue -:CfgAbstractNext-> firstcfgnode; }
    negative { lastcfgnode -:CfgAbstractNext-> fcn_epilogue; }

    modify {
        fcn_prologue -:CfgNext-> firstcfgnode;
        lastcfgnode -:CfgNext-> fcn_epilogue;
    }
}

rule cfgSetNextFcnDef {
    fcndef:MemberFcn -:FcnBody-> body:ScAstNode;
    negative { fcndef -:tmpCfgDone-> fcndef; }
    modify {
        fcndef -:tmpCfgDone-> fcndef;
        exec(cfgEnclosingPrologueEpilogue(fcndef, body, body));
    }
}

rule cfgSetNextIgnoreSubtree {
    x:ScAstNode -:CfgPrologue-> y:CfgNormalNode;
    x -:CfgEpilogue-> z:CfgNormalNode;
    negative { y -:CfgAbstractNext-> .; }
    modify {
        y -:CfgSkipSubtreeNext-> z;
    }
}

rule deleteTmpEdges {
    y:Node -x:tmpCfgDone-> y;
    modify { delete(x); }
}

rule cfgInit {
    // NOTE -- check this file with check_generated_files.py
    modify { exec(
        // @ generate command, run on this file
        // grep -oE 'rule cfgInit([a-zA-Z0-9]+)' | sed 's/rule //g' |
        // awk '{ print $0 "* |"; }'
        // @ begin generate block
        cfgInitReturnNodes* |
        cfgInitEnclosingNodes* |
        cfgInitOtherNodes* |
        // @ end generate block

        // @ generate command, run on this file
        // grep -oE 'rule cfgSetAttachable([a-zA-Z0-9]+)' | sed 's/rule //g' |
        // awk '{ print $0 "* |"; }'
        // @ begin generate block
        cfgSetAttachableMemberFcns* |
        cfgSetAttachableBlocks* |
        cfgSetAttachableBlockExpr* |
        // @ end generate block

        // @ generate command, run on this file
        // grep -oE 'rule cfgSetNext([a-zA-Z0-9]+)' | sed 's/rule //g' |
        // awk '{ print $0 "* | [deleteTmpEdges] |"; }'
        // @ begin generate block
        cfgSetNextForValDef* | [deleteTmpEdges] |
        cfgSetNextForBlockArgs* | [deleteTmpEdges] |
        cfgSetNextForScalaBlocks* | [deleteTmpEdges] |
        cfgSetNextForSketchBlocks* | [deleteTmpEdges] |
        cfgSetNextForFcnArgs* | [deleteTmpEdges] |
        cfgSetNextIntraFcn* | [deleteTmpEdges] |
        cfgSetNextFcnDef* | [deleteTmpEdges] |
        cfgSetNextIgnoreSubtree* | [deleteTmpEdges] |
        // @ end generate block

        [deleteTmpEdges]); }
}
