// -*- coding: utf-8 -*-
// author: gatoatigrado (nicholas tung) [ntung at ntung]

// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain a
// copy of the License at http://www.apache.org/licenses/LICENSE-2.0 .

// The control flow graph -- a structure linked to the AST.
// Currently, the CFG is used to attach additional data, which
// is moved back to the AST.

// STEP 1: Links from AST to CFG
// based on AST node type

rule cfgInitReturnNodes {
    ret:Return;
    negative { ret -:CfgPrologue-> .; }
    modify {
        ret -:CfgPrologue-> prologue:CfgEvalNormalNode;
        ret -:CfgEpilogue-> epilogue:CfgReturnNode;
    }
}

/// NOTE -- this function is slightly fragile, in that
/// return *must* be processed before.
rule cfgInitEnclosingNodes {
    x : ScAstNode -:Subtree-> :ScAstNode;

    // don't break function boundaries, and leave the graph
    // a little prettier. sync with below
    negative { if { typeof(x) <= ClassDef ||
        typeof(x) <= PackageDef || typeof(x) <= Template; } }

    negative { x -:CfgPrologue-> .; }
    modify {
        x -:CfgPrologue-> prologue:CfgDummyPrologueNode;
        x -:CfgEpilogue-> epilogue:CfgEvalNormalNode;
    }
}

/// this works if the others are initialized first :)
/// This code can also be used:
/// negative { if { typeof(x) < FcnCall; } }
/// negative { if { typeof(x) < Return; } }
rule cfgInitOtherNodes {
    x:ScAstNode;

    // sync with above
    negative { if { typeof(x) <= ClassDef ||
        typeof(x) <= PackageDef || typeof(x) <= Template; } }

    negative { x -:CfgPrologue-> .; }
    negative { x; x -:Subtree-> y:ScAstNode; }
    modify {
        x -:CfgPrologueEpilogue-> :CfgEvalNormalNode;
    }
}



// STEP 2: Edges from CFG to CFG nodes
// based on AST edge types

/// general function to wire x's epilogue to y's prologue.
rule cfgEpilogueToPrologueNext(x : ScAstNode, y : ScAstNode) {
    x -:CfgEpilogue-> x_epilogue:CfgNormalNode;
    y -:CfgPrologue-> y_prologue:CfgNormalNode;
    negative { x_epilogue -:CfgAbstractNext-> y_prologue; }
    modify { x_epilogue -:CfgNext-> y_prologue; }
}

/// general function to connect internal nodes (first and last) to
/// the prologue and epilogue of an enclosing node.
rule cfgEnclosingPrologueEpilogue(enclosing : ScAstNode,
    first : ScAstNode, last : ScAstNode)
{
    enclosing -:CfgPrologue-> enclosing_prologue:CfgNormalNode;
    enclosing -:CfgEpilogue-> enclosing_epilogue:CfgNormalNode;
    first -prologue_edge:CfgPrologue-> first_prologue:CfgNormalNode;
    last -epilogue_edge:CfgEpilogue-> last_epilogue:CfgNormalNode;
    hom(first, last);
    hom(prologue_edge, epilogue_edge);
    hom(first_prologue, last_epilogue);
    negative { enclosing_prologue -:CfgAbstractNext-> first_prologue; }
    negative { last_epilogue -:CfgAbstractNext-> enclosing_epilogue; }
    modify {
        enclosing_prologue -:CfgNext-> first_prologue;
        last_epilogue -:CfgNext-> enclosing_epilogue;
    }
}

rule cfgSetAttachableMemberFcns {
    fcndef:MemberFcn -:CfgPrologue-> prologue:CfgNormalNode;
    negative { prologue -:CfgAbstractAttachable-> prologue; }
    modify { prologue -:CfgImplicitAttachable-> prologue; }
}

// won't conflict above since member functions won't be in blocks.
rule cfgSetBlockAttachable {
    . -:BlockStmt-> x:ScAstNode -:CfgPrologue-> prologue:CfgNormalNode;
    negative { prologue -:CfgAbstractAttachable-> prologue; }
    modify { prologue -:CfgAttachable-> prologue; }
}



rule cfgSetNextForValDef {
    valdef:ValDef -:ValDefRhs-> rhs:ScAstNode;
    negative { valdef -:tmpCfgDone-> valdef; }
    modify {
        valdef -:tmpCfgDone-> valdef;
        exec(cfgEnclosingPrologueEpilogue(valdef, rhs, rhs));
    }
}

rule cfgSetNextForBlockArgs {
    x:ScAstNode -:BlockStmtNext-> y:ScAstNode;
    negative { x -:tmpCfgDone-> x; }
    modify {
        x -:tmpCfgDone-> x;
        exec(cfgEpilogueToPrologueNext(x, y));
    }
}

rule cfgSetNextForScalaBlocks {
    block:Block;
    block -:BlockStmtChain-> first:ScAstNode;
    block -:BlockStmtLast-> last:ScAstNode;
    block -:BlockExpr-> expr:ScAstNode;
    hom(first, last);
    negative { block -:tmpCfgDone-> block; }
    modify {
        block -:tmpCfgDone-> block;
        exec(cfgEpilogueToPrologueNext(last, expr) |
             cfgEnclosingPrologueEpilogue(block, first, expr));
    }
}

rule cfgSetNextForSketchBlocks {
    block:SKBlock;
    block -:BlockStmtChain-> first:ScAstNode;
    block -:BlockStmtLast-> last:ScAstNode;
    hom(first, last);
    negative { block -:tmpCfgDone-> block; }
    modify {
        block -:tmpCfgDone-> block;
        exec(cfgEnclosingPrologueEpilogue(block, first, last));
    }
}

rule cfgSetNextForFcnArgs {
    x:ScAstNode -:CfgEpilogue-> x_epilogue:CfgNormalNode;
    y:ScAstNode -:CfgPrologue-> y_prologue:CfgNormalNode;
    x -:FcnArgNext-> y;
    negative { x_epilogue -:CfgAbstractNext-> y_prologue; }
    modify { x_epilogue -:CfgNext-> y_prologue; }
}

rule cfgSetNextIntraFcn {
    fcn:FcnCall -:FcnArgChain-> first:ScAstNode;
    fcn -:FcnArgLast-> last:ScAstNode;
    fcn -:CfgPrologue-> fcn_prologue:CfgNode;
    fcn -:CfgEpilogue-> fcn_epilogue:CfgNode;

    first -firstcfgedge:CfgPrologue-> firstcfgnode:CfgNode;
    last -lastcfgedge:CfgEpilogue-> lastcfgnode:CfgNode;

    hom(first, last);
    hom(firstcfgedge, lastcfgedge);
    hom(firstcfgnode, lastcfgnode);
    hom(fcn_prologue, fcn_epilogue); // in case behavior above changes

    negative { fcn_prologue -:CfgAbstractNext-> firstcfgnode; }
    negative { lastcfgnode -:CfgAbstractNext-> fcn_epilogue; }

    modify {
        fcn_prologue -:CfgNext-> firstcfgnode;
        lastcfgnode -:CfgNext-> fcn_epilogue;
    }
}

rule cfgSetNextFcnDef {
    fcndef:MemberFcn -:FcnBody-> body:ScAstNode;
    negative { fcndef -:tmpCfgDone-> fcndef; }
    modify {
        fcndef -:tmpCfgDone-> fcndef;
        exec(cfgEnclosingPrologueEpilogue(fcndef, body, body));
    }
}

rule cfgSetNextIgnoreSubtree {
    x:ScAstNode -:CfgPrologue-> y:CfgNormalNode;
    x -:CfgEpilogue-> z:CfgNormalNode;
    negative { y -:CfgAbstractNext-> .; }
    modify {
        y -:CfgSkipSubtreeNext-> z;
    }
}

rule deleteTmpEdges {
    y:Node -x:tmpCfgDone-> y;
    modify { delete(x); }
}

rule cfgInit {
    modify { exec(cfgInitReturnNodes* |
        cfgInitEnclosingNodes* |
        cfgInitOtherNodes* |
        cfgSetAttachableMemberFcns* |
        cfgSetBlockAttachable* |

        // generate with
        // grep -oE 'rule cfgSetNext([a-zA-Z0-9]+)' | sed 's/rule //g' | awk '{ print $0 "* | [deleteTmpEdges] |"; }'
        cfgSetNextForValDef* | [deleteTmpEdges] |
        cfgSetNextForBlockArgs* | [deleteTmpEdges] |
        cfgSetNextForScalaBlocks* | [deleteTmpEdges] |
        cfgSetNextForSketchBlocks* | [deleteTmpEdges] |
        cfgSetNextForFcnArgs* | [deleteTmpEdges] |
        cfgSetNextIntraFcn* | [deleteTmpEdges] |
        cfgSetNextFcnDef* | [deleteTmpEdges] |
        cfgSetNextIgnoreSubtree* | [deleteTmpEdges] |

        [deleteTmpEdges]); }
}

// TEST -- member functions are connected from beginning to end
rule testCfgConnectedInit {
    fcn:MemberFcn -:CfgEpilogue-> epilogue:CfgNormalNode;
    modify {
        epilogue -:CfgIsConnected-> epilogue;
    }
}

rule testCfgConnectedPropagate {
    x:CfgNode -:CfgAbstractNext-> connected:CfgNode;
    connected -:CfgIsConnected-> connected;
    negative { x -:CfgIsConnected-> x; }
    modify {
        x -:CfgIsConnected-> x;
    }
}

rule testCfgConnectedFcnDefsEchoError {
    fcn:MemberFcn -:CfgPrologue-> prologue:CfgNormalNode;
    fcn -:ScTermSymbol-> fcnsym:Symbol;
    negative {
        prologue -:CfgIsConnected-> prologue;
    }
    modify { emit("[GRG ASSERT FAILURE] unconnected function: "
        + fcnsym.symbolName + "\n"); }
}

rule testCfgConnectedEchoError {
    x:ScAstNode --> cfgnode:CfgNormalNode;
    negative {
        cfgnode -:CfgAbstractNext-> z:Node;
        a:Node -:CfgAbstractNext-> cfgnode;
        hom(a, z);
    }
    modify { emit("[GRG ASSERT FAILURE] unconnected node: ");
        emit(x); emit("\n"); }
}

rule deleteCfgIsConnected {
    y:CfgNode -e:CfgIsConnected-> y;
    modify { delete(e); }
}
