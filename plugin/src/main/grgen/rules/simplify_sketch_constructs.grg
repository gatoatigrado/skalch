// -*- coding: utf-8 -*-
// author: gatoatigrado (nicholas tung) [ntung at ntung]

// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain a
// copy of the License at http://www.apache.org/licenses/LICENSE-2.0 .

// rewrite sketch constructs

rule replaceAssertCalls {
    fcn:FcnCall -:FcnCallSymbol-> :AssertFcnSymbol;
    fcn -:FcnTarget-> . --> :AngelicSketchSymbol;
    modify {
        assert:SKAssert<fcn>;
    }
}

rule retypeBangBangCall(resolv_call:FcnCall, sk_sym:SketchConstructSymbol) {
    if { typeof(sk_sym) == BangBangSymbol; }
    modify { new_call:BangBangCall<resolv_call>; }
}

rule retypeHoleCall(resolv_call:FcnCall, sk_sym:SketchConstructSymbol) {
    if { typeof(sk_sym) == HoleSymbol; }
    modify { new_call:HoleCall<resolv_call>; }
}

rule replaceConstructCalls {
    resolv_call:FcnCall -:FcnArgChain-> constr_call:FcnCall
        -:FcnCallSymbol-> sk_sym:SketchConstructSymbol;
    resolv_call -rcsymedge:FcnCallSymbol-> resolv_sym:Symbol;
    resolv_call -targetedge:FcnTarget-> .;
    if { resolv_sym.symbolName == "_resolve"; }
    modify {
        exec(retypeBangBangCall(resolv_call, sk_sym) ||
            retypeHoleCall(resolv_call, sk_sym));
    }
}

// more artifacts from the Scala view
rule unboxConstructCalls() {
    unbox_call:FcnCall -unboxedge:FcnCallSymbol-> unbox_sym:ScalaUnboxSymbol;
    unbox_call -constredge:FcnArgChain-> constr_sym:SketchConstructCall;
    unbox_call -targetedge:FcnTarget-> n:Node;
    unbox_call -constrlastedge:FcnArgLast-> constr_sym;
    modify {
        delete(unboxedge, constredge, targetedge, constrlastedge);
        boolean_call:typeof(constr_sym)<unbox_call>;
    }
}

rule simplifyClassConstruction() {
    // typed to a class that can be construct assigned
    type_resolv:FcnCallTypeApply -old_type_args:FcnCallTypeArgsChain-> type_tree:TypeTree;
    type_tree -:TypeTreeTypeSymbol-> clssym:Symbol;
    clsdef:ClassDef -:ClassDefSymbol-> clssym;
    clsdef -:CanBeConstructAssigned-> clsdef;

    // is a sketch construct
    type_resolv -old_target:FcnTarget-> :FieldAccess -:FieldAccessObject->
        sk_constr:SketchConstructCall;
    type_resolv -old_args:FcnArgChain-> :EmptyChain;

    // delete other edges
    type_resolv -old_call_sym:FcnCallSymbol -> .;

    modify {
        delete(old_args, old_type_args, old_call_sym, old_target);
        new_sk_constr:typeof(sk_constr)<type_resolv>;
//         new_sk_constr -:FcnCallTypeSymbol-> clssym;
    }
}

// NOTE -- run this in parallel with remove dangling.
rule removeNopTypeCast() {
    typed:Typed -:TypedTypeSymbol-> sym:Symbol;
    typed -:TypedExpression-> expr:ScAstNode --> sym;
    modify {
        exec(redirect_incoming(typed, expr)* |
            redirect_outgoing_subtrees(typed, expr));
    }
}
