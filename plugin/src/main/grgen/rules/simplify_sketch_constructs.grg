// -*- coding: utf-8 -*-
// author: gatoatigrado (nicholas tung) [ntung at ntung]

// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain a
// copy of the License at http://www.apache.org/licenses/LICENSE-2.0 .

// rewrite sketch constructs
rule replaceAssertCalls {
    fcn:FcnCall -:FcnCallSymbol-> :AssertFcnSymbol;
    fcn -:FcnTarget-> . --> :AngelicSketchSymbol;
    modify {
        assert:SKAssert<fcn>;
    }
}

rule replaceBangBangCalls {
    resolv_call:FcnCall -:FcnArgChain-> bang_bang_call:FcnCall
        -:FcnCallSymbol-> :BangBangSymbol;
    resolv_call -rcsymedge:FcnCallSymbol-> resolv_sym:Symbol;
    resolv_call -targetedge:FcnTarget-> .;
    if { resolv_sym.symbolName == "_resolve"; }
    modify {
        new_call:BangBangCall<resolv_call>;
    }
}

// more artifacts from the Scala view
rule unboxConstructCalls() {
    unbox_call:FcnCall -:FcnCallSymbol-> unbox_sym:ScalaSymbol;
    unbox_call -:FcnArgChain-> constr_sym:SketchConstructCall;
    unbox_call -:FcnTarget-> n:Node;
    if { unbox_sym.fullSymbolName == "scala.Boolean.unbox"; }
    replace {
        n;
        boolean_call:typeof(constr_sym)<unbox_call>;
    }
}

rule simplifyClassConstruction() {
    // typed to a class that can be construct assigned
    type_resolv:FcnCallTypeApply -old_type_args:FcnCallTypeArgsChain-> type_tree:TypeTree;
    type_tree -:TypeTreeTypeSymbol-> clssym:Symbol;
    clsdef:ClassDef -:ClassDefSymbol-> clssym;
    clsdef -:CanBeConstructAssigned-> clsdef;

    // is a sketch construct
    type_resolv -old_target:FcnTarget-> :FieldAccess -:FieldAccessObject->
        sk_constr:SketchConstructCall;
    type_resolv -old_args:FcnArgChain-> :EmptyChain;

    // delete other edges
    type_resolv -old_call_sym:FcnCallSymbol -> .;

    modify {
        delete(old_args, old_type_args, old_call_sym, old_target);
        new_sk_constr:typeof(sk_constr)<type_resolv>;
//         new_sk_constr -:FcnCallTypeSymbol-> clssym;
    }
}

// NOTE -- run this in parallel with remove dangling.
rule removeNopTypeCast() {
    typed:Typed -:TypedTypeSymbol-> sym:Symbol;
    typed -:TypedExpression-> expr:ScAstNode --> sym;
    modify {
        exec(redirect_incoming(typed, expr)*);
    }
}

// redirect all edges going to x as going to y instead
rule redirect_incoming(x : Node, y : Node) {
    z:Node -e:Edge-> x;
    modify {
        z -e2:typeof(e)-> y;
        delete(e);
    }
}
