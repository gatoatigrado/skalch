{% import "macros.grg" as macros with context %}

{% block comment %}
author: gatoatigrado (nicholas tung) [ntung at ntung]

Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain a
copy of the License at http://www.apache.org/licenses/LICENSE-2.0 .

create blocks for all function bodies.

{% endblock %}
{% block gm %}
// edge class MyEdge
// node class MyNode
{% endblock %}



{% block grs %}
echo "[REWRITE PRODUCTION] local simplifications"
xgrs removeFcnTarget*
xgrs (deleteDangling+ | removeNopTypeCast)*

echo "[REWRITE PRODUCTION] local simplifications -- retype unit blocks"
xgrs createFunctionBlocks* & retypeBlockSKBlock*
xgrs checkOnlyFcnBlocks
{% endblock %}



{% block grg %}
/// change f(x) = x to f(x) = { x }
rule createFunctionBlocks {
    x:FcnDef -fcn_body:FcnBody-> y:ScAstNode;
    x -:FcnDefReturnTypeSymbol-> z:Symbol;
    negative { if { typeof(y) >= Block; } }
    modify {
        delete(fcn_body);

        x -:FcnBody-> block:Block -:BlockExpr-> y;
        block -:BlockStmtChain-> et:EmptyTree;
        block -:BlockStmtLast-> et;
        block -:BlockTypeSymbol-> z;

        eval {
            {{ macros.copySrcPosition("y", ["block"]) }}
        }
    }
}

rule retypeBlockSKBlock {
    :FcnDef --> block:Block -e:BlockExpr-> expr:ScAstNode;
    block -e2:BlockStmtLast-> last:ScAstNode;
    if { typeof(block) == Block; }

    alternative {
        UnitType {
            block -:BlockTypeSymbol-> :ScalaUnitTypeSymbol;
            modify {
                next_block:SKBlock<block> -:BlockStmtLast-> expr;
                last -:BlockStmtNext-> expr;
            }
        }
        Typed {
            block -:BlockTypeSymbol-> blk_typ:Symbol;
            negative { if { typeof(blk_typ) >= ScalaUnitTypeSymbol; } }
            modify {
                next_block:SKBlock<block> -:BlockStmtLast-> ret:Return
                    -:ReturnSymbol-> :InsertedReturnSymbol -:TypeSymbol-> blk_typ;
                last -:BlockStmtNext-> ret;
                ret -:ReturnExpr-> expr;
            }
        }
    }
    modify { delete(e, e2); }
}

rule checkOnlyFcnBlocks {
    x:FcnDef -:FcnBody-> y:ScAstNode;
    x -:FcnDefSymbol-> fcn_sym:Symbol;
    if { typeof(y) != SKBlock; }
    modify { exec(printn(x) & printn(y) & assertFalse("not sketch block.")); }
}
{% endblock %}
